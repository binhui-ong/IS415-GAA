---
title: "Take-home Exercise 3: Prototyping Modules for Geospatial Analytics Shiny Application (not done)"
format: 
  html: 
    code-fold: true
    code-summary: "Show the code"
execute:
  freeze: true
  warning: false
editor: visual
date: "March 16, 2024"
---

# 1 Overview

## 1.1 Background

## 1.2 Objectives

## 1.3 The Task

## 1.4 The Data

## 1.5 Installing and Loading R Packages

In this exercise, the following R packages would be used:

Then, to install and/or load the R packages, we can use p_load() from the pacman package.

```{r}
pacman::p_load(sf, tidyverse, tmap, SpatialAcc, ggplot2, ggstatsplot, spDist, spNetwork, reshape2)
```

# 2 Data Preparation (Geospatial)

## 2.1 Data Import

Letâ€™s begin by introducing and preparing our geospatial data set in R!

To import geospatial data, we will be using st_read() from the sf package.

```{r}
#| eval: false
mpsz2019 <- st_read("data/MasterPlan2019SubzoneBoundaryNoSeaGEOJSON.geojson")
```
```{r}
#| eval: false
#| echo: false
write_rds(mpsz2019, "/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/mpsz2019.rds")
```

```{r}
#| echo: false
mpsz2019 <- readRDS("/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/mpsz2019.rds")
```

```{r}
mpsz2019
```

From the above, we can see that the mpsz2019 data is a multipolygon data in geodetic CRS WGS84, with Z dimensions.

```{r}
#| eval: false
eldercare_services <- st_read(dsn = "/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data",
                              layer = "ELDERCARE")
```

```{r}
#| eval: false
#| echo: false
write_rds(eldercare_services, "/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/eldercare_services.rds")
```

```{r}
#| echo: false
eldercare_services <- readRDS("/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/eldercare_services.rds")
```

```{r}
eldercare_services
```
The eldercare_services data set is point data, with dimensions XY and CRS SVY21.

Let's visualize how it looks like using plot() and st_geometry() from the sf package.

```{r}
#| eval: false
plot(st_geometry(mpsz2019))
```

```{r}
#| eval: false
plot(st_geometry(eldercare_services))
```


## 2.2 Data Pre-Processing

### 2.2.1 Dropping Z-dimension

```{r}
#| eval: false
mpsz <- st_zm(mpsz2019)
```

```{r}
#| eval: false
#| echo: false
write_rds(mpsz, "/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/mpsz.rds")
```

```{r}
#| echo: false
mpsz <- readRDS("/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/mpsz.rds")
```

### 2.2.2 Resolving invalid geometries


```{r}
length(which(st_is_valid(mpsz) == FALSE))
```

```{r}
length(which(st_is_valid(eldercare_services) == FALSE))
```

```{r}
mpsz <- st_make_valid(mpsz)
```

```{r}
length(which(st_is_valid(mpsz) == FALSE))
```

### 2.2.3 Handling missing values

```{r}
mpsz[rowSums(is.na(mpsz)) != 0, ]
```

```{r}
eldercare_services[rowSums(is.na(eldercare_services)) != 0, ]
```

```{r}
eldercare_services[rowSums(is.na(eldercare_services %>% select(11,19))) != 0, ]
```

### 2.2.4 Changing and verifying CRS

```{r}
st_crs(mpsz)
```
The mpsz data set is not in our desired coordinate system (SVY21; EPSG: 3414). Hence, we need to reproject it.

```{r}
st_crs(eldercare_services)
```

The eldercare_services data set does not have the correct EPSG code (3414). Hence, we must reassign the EPSG code to it.

```{r}
#| eval: false
mpsz_sf <- st_transform(mpsz, 3414)
```

```{r}
#| eval: false
eldercare <- st_set_crs(eldercare_services, 3414)
```

### 2.2.6 Extraction of relevant columns

#### 2.2.6.1 Extraction of subzone and planning area names in mpsz_sf

For subzone: 
```{r}
#| eval: false
mpsz_sf <- mpsz_sf %>%  
  rowwise() %>%
  mutate(SUBZONE= str_extract(`Description`, "<th>SUBZONE_N</th> <td>(.*?)</td>")) %>% ungroup()
```

```{r}
#| eval: false
mpsz_sf$SUBZONE <- str_remove_all(mpsz_sf$SUBZONE, "<.*?>|SUBZONE_N")
```

For planning area:
```{r}
#| eval: false
mpsz_sf <- mpsz_sf %>%  
  rowwise() %>%
  mutate(PLAN_AREA= str_extract(`Description`, "<th>PLN_AREA_N</th> <td>(.*?)</td>")) %>% ungroup()
```

```{r}
#| eval: false
mpsz_sf$PLAN_AREA <- str_remove_all(mpsz_sf$PLAN_AREA, "<.*?>|PLN_AREA_N")
```

```{r}
#| eval: false
#| echo: false
write_rds(mpsz_sf, "/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/mpsz_sf.rds")
```

```{r}
#| echo: false
mpsz_sf <- readRDS("/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/mpsz_sf.rds")
```

```{r}
mpsz_sf
```

#### 2.2.6.2 Keeping only relevant columns in eldercare
```{r}
#| eval: false
eldercare <- eldercare %>% select(11,19)
```

```{r}
#| eval: false
#| echo: false
write_rds(eldercare, "/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/eldercare.rds")
```

```{r}
#| echo: false
eldercare <- readRDS("/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/eldercare.rds")
```

```{r}
eldercare
```

### 2.2.7 Creating hexagon data (******** NEED TO WORK HERE*****)

```{r}
#| eval: false
#| echo: false
hexagon <- st_make_grid(mpsz_sf, cellsize = 250, what = "polygons", square = FALSE)
```

```{r}
#| eval: false
#| echo: false
hexagon
```

```{r}
#| eval: false
#| echo: false
plot(st_geometry(hexagon))
```


# 3 Data Preparation (Distance Matrix)

The first step to dealing with our aspatial data is to import it into our R environment. To do so, we can use read_csv() from the readr package.

## 3.1 Computing Distance Matrix

### 3.1.1 Converting from sf data.table to SpatialPolygonsDataFrame

```{r}
#| eval: false
mpsz_sp <- as(mpsz_sf, "Spatial")
```

```{r}
#| eval: false
#| echo: false
write_rds(mpsz_sp, "/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/mpsz_sp.rds")
```

```{r}
#| echo: false
mpsz_sp <- readRDS("/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/mpsz_sp.rds")
```

```{r}
mpsz_sp
```

### 3.1.2 Computing the distance matrix

```{r}
#| eval: false
dist_matrix <- spDists(mpsz_sp, longlat = FALSE)
```

```{r}
#| eval: false
#| echo: false
write_rds(dist_matrix, "/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/dist_matrix.rds")
```

```{r}
#| echo: false
dist_matrix <- readRDS("/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/dist_matrix.rds")
```

```{r}
head(dist_matrix, n = c(10,10))
```

### 3.1.3 Labelling column and row headers of a distance matrix

```{r}
sz_names <- mpsz_sf$SUBZONE
```

```{r}
colnames(dist_matrix) <- paste0(sz_names)
rownames(dist_matrix) <- paste0(sz_names)
```


### 3.1.4 Pivoting distance value by SUBZONE name

```{r}
#| eval: false
#| echo: false
distPair <- melt(dist_matrix) %>% 
  rename(dist = value) %>%
  rename(origin = Var1) %>%
  rename(dest = Var2)
```

```{r}
#| eval: false
#| echo: false
write_rds(distPair, "/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/distPair.rds")
```

```{r}
#| echo: false
distPair <- readRDS("/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/distPair.rds")
```

```{r}
head(distPair)
```

### 3.1.5 Updating intra-zonal distances

```{r}
distPair %>% filter(dist > 0) %>%
  summary()
```

From the results, we can see that the minimum distance is 173.8m.

Next, a constant distance of 50m is added into the intra-zones distance.

```{r}
distPair$dist <- ifelse(distPair$dist == 0, 50, distPair$dist)
```

The code below can be used to check the result data.frame.

```{r}
distPair %>% summary()
```

```{r}
#| eval: false
distmat_km <- as.matrix(dist_matrix/1000)
```

```{r}
#| eval: false
#| echo: false
write_rds(distmat_km, "/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/distmat_km.rds")
```

```{r}
#| echo: false
distmat_km <- readRDS("/Users/binhui-ong/IS415-GAA/Take-home_Ex/Take-home_Ex03/data/rds/distmat_km.rds")
```

# 4 Modelling and Visualizing Accesssibility using Hansen Method (requires hexagon)

## 4.1 Computing Hansen's accessibility (requires hexagon)

```{r}

```

## 4.2 Visualizing Hansen's accessibility 

### 4.2.1 Extracting map extend (requires hexagon)

```{r}

```

```{r}

```

### 4.3 Statistical graphic visualization


