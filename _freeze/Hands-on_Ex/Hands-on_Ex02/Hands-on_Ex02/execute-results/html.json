{
  "hash": "5343dba47fe9caa2d960f404a9e06284",
  "result": {
    "markdown": "---\ntitle: \"Hands-on Exercise 2: Thematic Mapping and GeoVisualization with R\"\nexecute:\n  freeze: true\n  warning: FALSE\ndate: \"January 13, 2024\"\n---\n\n\n# 2.1 Overview\n\nIn this exercise, I will be demonstrating the use of R packages to create themed maps that are helpful to visualize geospatial data.\n\n# 2.2 Data Acquisition\n\nWe will be using the following data:\n\n-   Master Plan 2014 Subzone Boundary (Web) in ESRI shapefile format.\n\n    -   Source: data.gov.sg.\n\n    -   This is a geospatial data that based on URA Master Plan 2014, consisting of the geographical boundary of Singapore at the planning subzone level.\n\n-   Singapore Residents by Planning Area / Subzone, Age Group, Sex and Type of Dwelling, June 2011-2020 in csv format\n\n    -   Source: Department of Statistics, Singapore\n\n# 2.3 Getting Started\n\nIn this exercise, our key to visualizing the data is to use the tmap package in R. Additionally, we would be using the following R packages to prepare the data:\n\n-   readr for importing delimted text file,\n\n-   tidyr for tidying data,\n\n-   dplyr for wrangling data and\n\n-   sf for handling geospatial data.\n\nTo do so, we use p_load() from the pacman package to load the packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tmap, sf, tidyverse)\n```\n:::\n\n\n## 2.3.1 Importing Geospatial Data into R\n\nNext, we will import the MP14_SUBZONE_WEB_PL shapefile into R as a simple feature data frame called mpsz. Here, we use the st_read() from sf.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_read(dsn = \"data/geospatial\", \n                layer = \"MP14_SUBZONE_WEB_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/binhui-ong/IS415-GAA/Hands-on_Ex/Hands-on_Ex02/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n:::\n:::\n\n\nWe can examine the content of mpsz with the following code chunk.:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1  29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2  29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3  29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4  29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5  30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n6  29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...\n7  30230.86   3275.312   551732.0 MULTIPOLYGON (((27746.95 30...\n8  30222.86   2208.619   290184.7 MULTIPOLYGON (((29351.26 29...\n9  29893.78   6571.323  1084792.3 MULTIPOLYGON (((20996.49 30...\n10 30104.18   3454.239   631644.3 MULTIPOLYGON (((24472.11 29...\n```\n:::\n:::\n\n\nThe code chunk allows us to have a quick understanding of the data by displaying only the first 10, out of 323, records.\n\n## 2.3.2 Importing Attribute (Aspatial) Data into R\n\nNext, we would be importing into the respopagesextod2011to2020.csv file into R.\n\nWe will use read_csv() from the readr package and save it as a data frame called popdata.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata <- read_csv(\"data/aspatial/respopagesextod2011to2020.csv\")\n```\n:::\n\n\n## 2.3.3 Data Preparation\n\nIn this exercise, we aim to use the attribute data that only has year 2020 values, with variables PA, SZ, YOUNG, ECONOMY ACTIVE, AGED, TOTAL, DEPENDENCY, where\n\n-   YOUNG: age group 0 to 4 until age group 20 to 24,\n\n-   ECONOMY ACTIVE: age group 25-29 until age group 60-64,\n\n-   AGED: age group 65 and above,\n\n-   TOTAL: all age group, and\n\n-   DEPENDENCY: the ratio between young and aged against economy active group.\n\nIn the following two sub-sections, we will prepare the relevant attribute data, and combine it with the geospatial data to produce a new data frame for our map production.\n\n### 2.3.3.1. Data wrangling\n\nWe will use the following data wrangling and transformation functions to extract the relevant data.\n\n-   pivot_wider() of tidyr package, and mutate(), filter(), group_by()\n\n-   select() of dplyr package\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2020 <- popdata %>%\n  filter(Time == 2020) %>%\n  group_by(PA, SZ, AG) %>%\n  summarise(`POP` = sum(`Pop`)) %>%\n  ungroup()%>%\n  pivot_wider(names_from=AG, \n              values_from=POP) %>%\n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[14])) %>%\nmutate(`ECONOMY ACTIVE` = rowSums(.[7:13])+\nrowSums(.[15]))%>%\nmutate(`AGED`=rowSums(.[16:21])) %>%\nmutate(`TOTAL`=rowSums(.[3:21])) %>%  \nmutate(`DEPENDENCY` = (`YOUNG` + `AGED`)\n/`ECONOMY ACTIVE`) %>%\n  select(`PA`, `SZ`, `YOUNG`, \n       `ECONOMY ACTIVE`, `AGED`, \n       `TOTAL`, `DEPENDENCY`)\n```\n:::\n\n\nNext, before conducting the join, we must convert the values in PA and SZ fields in the attribute data to uppercase. This is because the fields are currently in a mix of upper- and lowercase, while in the geospatial data, SUBZONE_N and PLN_AREA_N are in uppercase.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2020 <- popdata2020 |>\n  mutate_at(.vars= vars(`PA`, `SZ`), .funs = list(toupper))\n\npopdata2020\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 332 × 7\n   PA         SZ                   YOUNG `ECONOMY ACTIVE`  AGED TOTAL DEPENDENCY\n   <chr>      <chr>                <dbl>            <dbl> <dbl> <dbl>      <dbl>\n 1 ANG MO KIO ANG MO KIO TOWN CEN…  1290             2760   760  4810      0.743\n 2 ANG MO KIO CHENG SAN             5640            16460  6050 28150      0.710\n 3 ANG MO KIO CHONG BOON            5100            15000  6470 26570      0.771\n 4 ANG MO KIO KEBUN BAHRU           4620            13010  5120 22750      0.749\n 5 ANG MO KIO SEMBAWANG HILLS       1880             3630  1310  6820      0.879\n 6 ANG MO KIO SHANGRI-LA            3330             9050  3610 15990      0.767\n 7 ANG MO KIO TAGORE                1940             4480  1530  7950      0.775\n 8 ANG MO KIO TOWNSVILLE            4190            11950  5100 21240      0.777\n 9 ANG MO KIO YIO CHU KANG             0                0     0     0    NaN    \n10 ANG MO KIO YIO CHU KANG EAST     1110             2410   750  4270      0.772\n# ℹ 322 more rows\n```\n:::\n:::\n\n\n### 2.3.3.2 Joining the geospatial and attribute data\n\nNow, we are ready to combine the geospatial and attribute data! For this step, we use left_join() from the dplyr package to join the attribute data to the geographical data, using planning subzone name (i.e SUBZONE_N and SZ) as the common identifier.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_pop2020 <- left_join(mpsz,popdata2020, by = c(\"SUBZONE_N\" = \"SZ\"))\n```\n:::\n\n\nAs the output follows the format of the left data frame in left_join, using mpsz as our left data table ensures that the output would also be a simple feature data frame.\n\nNow that we are almost done with our data preparation, the last step is to save the data as a file in our directory for future use.\n\nTo do so, we must create a new folder \"rds\" in our directory. Thereafter, we apply the code chunk below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(mpsz_pop2020,\"data/rds/mpsz_popdata2020.rds\")\n```\n:::\n\n\n# 2.4 Choropleth Mapping Geospatial Data Using tmap\n\nChoropleth mapping involves the symbolisation of enumeration units, such as countries, provinces, states, counties or census units, using area patterns or graduated colors.\n\nFor instance, a social scientist may need to use a choropleth map to portray the spatial distribution of aged population of Singapore by Master Plan 2014 Subzone Boundary.\n\nTo prepare a thematic map, we can use any of the following two approaches, each with its own pros:\n\n-   Approach 1: Use qtm()\n\n    -   Pro: Plots a thematic map quickly\n\n    -   Con: Simpler and less customizable\n\n-   Approach 2: Use tmap elements\n\n    -   Pro: Plots a highly customisable thematic map\n\n    -   Con: Requires more time and coding\n\n## 2.4.1 Approach 1: Plot a choropleth map quickly using qtm()\n\nThis approach uses tmap to draw a choropleth map simply and quickly. It is concise and give a good default visualization in many cases.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\nqtm(mpsz_pop2020, fill = \"DEPENDENCY\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nIn the above code, tmap_mode() with \"plot\" input produces a static map. To produce an interactive map, we should use \"view\" input.\n\nAdditionally, the fill argument is used to map the attribute.\n\nNonetheless, this approach limits our ability to customize the map. To create a high quality cartographic choropleth map, we should use tmap's drawing elements shown in the following Approach 2.\n\n## 2.4.2 Approach 2: Creating a choropleth map using tmap's elements\n\nThe second approach involves adding tmap's elements layer by layer to create a high quality cartographic choropleth map like the one below. It also allows us to customize various details of the map such as fill and border transparency, and title position through *options* *(such as \"alpha=\" for fill transparency)* within the functions to best suit our aesthetic needs.\n\nIt is more complicated and lengthy, but definitely rewarding when we want a beautiful graph!\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n**Steps**\n\nStep 1: Draw a base map\n\nTo begin, we would need to input the basic building block of tmap, which is tm_shape(). Thereafter, we add layers of elements such as **tm_polygons()** *(or tm_fills() which will be shown later)* to assign the target variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n    tm_polygons()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nStep 2: Assigning target variable to **tm_polygons()**\n\nSince our target variable is \"DEPENDENCY\", we would assign it to **tm_polygons()**. It will create a map with borders within the map and fills to represent the target variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n    tm_polygons(\"DEPENDENCY\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nNote: If we want to adjust the transparency of the borders or fills, we can do so with the *border.alpha* and *alpha* options respectively.\n\n*Alternative to tm_polygons(): **tm_fills()** and **tm_borders()***\n\nIn a case in which we do not want the borders within the map, we can use **tm_fill()** instead of tm_polygons.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n    tm_fill(\"DEPENDENCY\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nThen, if we want to include the borders too, we can add a layer with **tm_borders()**.\n\nThe combination of **tm_fill()** and **tm_borders()** would results in the same map as that with **tm_polygons()** in the first code chunk of this step (shown earlier on).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n    tm_fill(\"DEPENDENCY\") +\n  tm_borders(col= \"tomato\", lwd = 0.2, alpha =0.8, lty = \"dashed\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nThe above is an example of how we made some adjustments to the appearance of the borders:\n\n-   border color: \"tomato\"\n\n-   border line width (lwd): 0.1\n\n-   border transparency: 0.9 (where 0 = completely transparent and 1 = completely opaque)\n\n-   border line type: dashed\n\n## 2.4.3 Data classification methods of tmap\n\n### 2.4.3.1 Plotting choropleth maps using built-in classification methods\n\nMost choropleth maps use some methods of data classification to group a large number of observations into data ranges or classes.\n\ntmap provides a total of ten data classification methods for our needs, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, jenks\n\nTo define a data classification method, the *style* option in **tm_polygons()** or **tm_fill()** can be applied.\n\nIn the following examples, I will be using **tm_polygons()** to exhibit how different data classifications and different number of classes can affect the maps produced.\n\nExample 1: Different data classification with the same number of classes\n\nData classification with quantile data classification that uses 5 classes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) + \n  tm_polygons(\"DEPENDENCY\", style = \"quantile\", n=5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nData classification with equal data classification that uses 5 classes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) + \n  tm_polygons(\"DEPENDENCY\", style = \"equal\", n=5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nFrom the maps generated by the two different data classification methods, we can see that the quantile data classification method produces a more evenly distribution compared to the equal data classification method, even though they have the same number of classes.\n\nExample 2: Data classification with the same data classification, using different number of classes\n\nData classification with equal data classification that uses 4 classes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) + \n  tm_polygons(\"DEPENDENCY\", style = \"equal\", n=4)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nData classification with equal data classification that uses 10 classes\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) + \n  tm_polygons(\"DEPENDENCY\", style = \"equal\", n=10)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nFrom the maps generated by the two different number of classes, we can see that using 4 classes produces a more evenly distribution compared to using 10 classes, even though they employ the same data classification method.\n\nIn summary, it is important to note that our choice of data classification and classes can significantly affect the distribution in maps, which can in turn affect the reader's insights drawn from the map, especially at first glance.\n\n### 2.4.3.2 Plotting choropleth maps with customized breaks\n\nFor all built-in styles, the category breaks are computed internally. To set particular breaks, the breakpoints can be set explicitly using the \"breaks= \" argument in **tm_polygons()** or **tm_fill()**.\n\nIt is important to note that in tmap, the breaks include minimum and maximum points. Hence, for n categories, we must have (n+1) elements in the \"breaks=\" option, in increasing order.\n\nBefore we begin, we should attain some descriptive statistics to get an idea of where we should set our break points. To compute the descriptive statistics of \"DEPENDENCY\" field, we apply the following code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(mpsz_pop2020$DEPENDENCY)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.0000  0.6519  0.7025  0.7742  0.7645 19.0000      92 \n```\n:::\n:::\n\n\nFrom the descriptive statistics, we can reasonably set break points at 0.60, 0.70, 0.80 and 0.90, and include our minimum point as 0 and maximum point as 100. The resulting breaks vector is c(0, 0.60, 0.70, 0.80, 0.90).\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) + \n  tm_polygons(\"DEPENDENCY\", breaks = c(0, 0.60, 0.70, 0.80, 0.90)) \n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\nAs we can see, setting our own breaks has appeared to create a more meaningful representation of the distribution. Hence, when classifying data, we should compare this method with the built-in functions method (section 2.4.3.1) and employ the method that produces a more meaningful result.\n\n## 2.4.4 Color Scheme\n\ntmap supports color ramps defined by the user or a set of predefined color ramps from the RColorBrewer package.\n\n### 2.4.4.1 Using ColorBrewer palette\n\nTo change the color, we assign the preferred color to the *palette* option of **tm_polygons()** or **tm_fill()**. For instance, in the code chunk below, we assign \"Blues\" to the *palette* argument **tm_polygons**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) + \n  tm_polygons(\"DEPENDENCY\", \n          n=6,\n          style = \"quantile\", \n          palette = \"Blues\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\nTo reverse the color shading, we add a \"-\" prefix to the color.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) + \n  tm_polygons(\"DEPENDENCY\", \n          n=6,\n          style = \"quantile\", \n          palette = \"-Blues\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n## 2.4.5 Map Layouts\n\nMap layout refers to the combination of all map elements into a cohesive map. Map elements include among others the objects to be mapped, the title, the scale bar, the compass, margins and aspects ratios. Color settings and data classification methods covered in the previous section related to the palette and break-points are used to affect how the map looks.\n\n### 2.4.5.1 Map Legend\n\nIn tmap, several *legend* options are provided to change the placement, format and appearance of the legend.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) + \n  tm_polygons(\"DEPENDENCY\", \n              border.alpha = 0.5, \n              style = \"jenks\", \n              palette = \"Blues\", \n              legend.hist = TRUE, \n              legend.is.portrait = TRUE, \n              legend.hist.z = 0.1) + \n  tm_layout(main.title = \"Distribution of Dependency Ratio by Planning Subzone (Jenks Classification)\", \n            main.title.position = \"center\", \n            main.title.size = 1, \n            legend.height = 0.35,\n            legend.width = 0.35,\n            legend.outside = FALSE, \n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n### 2.4.5.2 Map Style\n\ntmap also allows a wide variety of layout settings to be adjusted. To do so, we can add **tmap_style()** to the code chunk.\n\nFor example, to use \"classic\" style in our map, we apply the following code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) + \n  tm_polygons(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\",\n          border.alpha = 0.5) +\n  tmap_style(\"classic\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n### 2.4.5.3 Cartographic Furniture\n\nIn addition to map style, tmap also provides arguments to draw other map furniture such as compass, scale bar and grid lines.\n\nIn the code chunk below, **tm_compass()**, **tm_scale_bar()** and **tm_grid()** are used to add compass, scale bar and grid lines onto to choropleth map.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) + \n  tm_polygons(\"DEPENDENCY\", \n              border.alpha = 0.5, \n              style = \"quantile\", \n              palette = \"Blues\") +\n  tm_layout(main.title = \"Distribution of Dependency Ratio by Planning Subzone (Quantile Classification)\", \n            main.title.position = \"center\", \n            main.title.size = 1, \n            legend.height = 0.35,\n            legend.width = 0.35,\n            legend.outside = FALSE, \n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_scale_bar(width = 0.15) + \n  tm_grid(lwd = 0.1, alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA) and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nTo reset the default style, we can use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_style(\"white\")\n```\n:::\n\n\n## 2.4.6 Drawing Small Multiple Choropleth Maps\n\nSmall multiple maps, also referred to as facet maps, are composed of many maps arranged side-by-side, and sometimes stacked vertically. They enable the visualization of how spatial relationships change with respect to another variable, such as time.\n\nIn tmap, small multiple maps can be plotted in three ways:\n\n-   Approach 1: By assigning multiple values to at least one the aesthetic arguments\n\n-   Approach 2: By defining a group-by variable in *tm_facets()*, and\n\n-   Approach 3: By creating multiple stand-alone maps with *tmap_arrange()*.\n\n### 2.4.6.1 Approach 1 ; Assign muliple values to at least one of the aesthetic arguments\n\nExample 1a: In this example, small multiple choropleth maps are created by defining *ncols* in **tm_polygons()**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) + \n  tm_polygons(c(\"YOUNG\", \"AGED\"),\n              style = \"equal\",\n              palette = \"Blues\",\n              border.alpha = 0.5) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"),\n            ) + \n  tmap_style(\"white\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\nExample 1b: In this example, small multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) + \n  tm_polygons(c(\"DEPENDENCY\", \"AGED\"), \n              style = c(\"equal\", \"quantile\"),\n              palette = list(\"Blues\", \"Greens\")) + \n  tm_layout(legend.position=c(\"right\", \"bottom\"))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n### 2.4.6.2 Approach 2: Define a group-by variable in tm_facets\n\nExample 2: In this example, multiple small choropleth maps are created using **tm_facets().**\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) + \n  tm_polygons(\"DEPENDENCY\",\n              style = \"quantile\",\n              palette = \"Blues\",\n              thres.poly = 0,\n              border.alpha = 0.5) + \n  tm_facets(by = \"REGION_N\",\n            free.coords = TRUE,\n            drop.units = TRUE) + \n  tm_layout(legend.show = FALSE, \n            title.position = c(\"center\", \"center\"),\n            title.size = 20)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n### 2.4.6.3 Approach 3: Create multiple stand-alone maps with tmap_arrange()\n\nIn this approach, we create different maps and combine them together with **tmap_arrange()**, in which we can customize how we want to arrange them using the *ncol* option.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyoungmap <- tm_shape(mpsz_pop2020) +\n  tm_polygons(\"YOUNG\", \n              style = \"quantile\",\n              palette = \"Blues\")\n\nagedmap <- tm_shape(mpsz_pop2020) +\n  tm_polygons(\"AGED\", \n              style = \"quantile\",\n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp = 1 ,ncol = 2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n## 2.4.7 Mapping Spatial Object Meeting a Selection Criterion\n\nInstead of creating small multiple choropleth map, you can also use selection function to map spatial objects that meet the selection criterion.\n\nFor example, if we want to map the \"DEPENDENCY\" distribution only for the \"CENTRAL REGION\" of Singapore, we can apply the following code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\",])+\n  tm_polygons(\"DEPENDENCY\",\n              style = \"quantile\",\n              palette = \"Blues\",\n              legend.hist = TRUE, \n              legend.is.portrait = TRUE,\n              legend.histz = 0.1,\n              border.alpha = 0.5) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.35,\n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex02_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n# 2.5 References\n\n## 2.5.1 tmap package\n\n-   [tmap: Thematic Maps in R](https://www.jstatsoft.org/article/view/v084i06)\n\n-   [tmap](https://cran.r-project.org/web/packages/tmap/)\n\n-   [tmap: get started!](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html)\n\n-   [tmap: changes in version 2.0](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-changes-v2.html)\n\n-   [tmap: creating thematic maps in a flexible way (useR!2015)](http://von-tijn.nl/tijn/research/presentations/tmap_user2015.pdf)\n\n-   [Exploring and presenting maps with tmap (useR!2017)](http://von-tijn.nl/tijn/research/presentations/tmap_user2017.pdf)\n\n## 2.5.2 Geospatial data wrangling\n\n-   [sf: Simple Features for R](https://cran.r-project.org/web/packages/sf/)\n\n-   [Simple Features for R: StandardizedSupport for Spatial Vector Data](https://journal.r-project.org/archive/2018/RJ-2018-009/RJ-2018-009.pdf)\n\n-   [Reading, Writing and Converting Simple Features](https://cran.r-project.org/web/packages/sf/vignettes/sf2.html)\n\n## 2.5.3 Data wrangling\n\n-   [dplyr](https://dplyr.tidyverse.org/)\n\n-   [Tidy data](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html)\n\n-   [tidyr: Easily Tidy Data with ‘spread()’ and ‘gather()’ Functions](https://cran.r-project.org/web/packages/tidyr/tidyr.pdf)\n\nWith the guide of Professor Kam Tin Seong.\n",
    "supporting": [
      "Hands-on_Ex02_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}